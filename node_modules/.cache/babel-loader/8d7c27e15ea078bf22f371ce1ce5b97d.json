{"remainingRequest":"C:\\work\\code\\iview-admin\\node_modules\\thread-loader\\dist\\cjs.js!C:\\work\\code\\iview-admin\\node_modules\\babel-loader\\lib\\index.js!C:\\work\\code\\iview-admin\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!C:\\work\\code\\iview-admin\\src\\components\\split-pane\\split.vue?vue&type=script&lang=js&","dependencies":[{"path":"C:\\work\\code\\iview-admin\\src\\components\\split-pane\\split.vue","mtime":1535094297031},{"path":"C:\\work\\code\\iview-admin\\.babelrc","mtime":1535094296553},{"path":"C:\\work\\code\\iview-admin\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1535091260613},{"path":"C:\\work\\code\\iview-admin\\node_modules\\thread-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\work\\code\\iview-admin\\node_modules\\babel-loader\\lib\\index.js","mtime":1529635966000},{"path":"C:\\work\\code\\iview-admin\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.number.constructor\";\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport { oneOf, on, off } from '@/libs/tools';\nimport Trigger from './trigger.vue';\nexport default {\n  name: 'SplitPane',\n  components: {\n    Trigger: Trigger\n  },\n  props: {\n    value: {\n      type: [Number, String],\n      default: 0.5\n    },\n    mode: {\n      validator: function validator(value) {\n        return oneOf(value, ['horizontal', 'vertical']);\n      },\n      default: 'horizontal'\n    },\n    min: {\n      type: [Number, String],\n      default: '40px'\n    },\n    max: {\n      type: [Number, String],\n      default: '40px'\n    }\n  },\n\n  /**\r\n   * Events\r\n   * @on-move-start\r\n   * @on-moving 返回值：事件对象，但是在事件对象中加入了两个参数：atMin(当前是否在最小值处), atMax(当前是否在最大值处)\r\n   * @on-move-end\r\n   */\n  data: function data() {\n    return {\n      prefix: 'ivu-split',\n      offset: 0,\n      oldOffset: 0,\n      isMoving: false\n    };\n  },\n  computed: {\n    wrapperClasses: function wrapperClasses() {\n      return [\"\".concat(this.prefix, \"-wrapper\"), this.isMoving ? 'no-select' : ''];\n    },\n    isHorizontal: function isHorizontal() {\n      return this.mode === 'horizontal';\n    },\n    anotherOffset: function anotherOffset() {\n      return 100 - this.offset;\n    },\n    valueIsPx: function valueIsPx() {\n      return typeof this.value === 'string';\n    },\n    offsetSize: function offsetSize() {\n      return this.isHorizontal ? 'offsetWidth' : 'offsetHeight';\n    },\n    computedMin: function computedMin() {\n      return this.getComputedThresholdValue('min');\n    },\n    computedMax: function computedMax() {\n      return this.getComputedThresholdValue('max');\n    }\n  },\n  methods: {\n    px2percent: function px2percent(numerator, denominator) {\n      return parseFloat(numerator) / parseFloat(denominator);\n    },\n    getComputedThresholdValue: function getComputedThresholdValue(type) {\n      var size = this.$refs.outerWrapper[this.offsetSize];\n      if (this.valueIsPx) return typeof this[type] === 'string' ? this[type] : size * this[type];else return typeof this[type] === 'string' ? this.px2percent(this[type], size) : this[type];\n    },\n    getMin: function getMin(value1, value2) {\n      if (this.valueIsPx) return \"\".concat(Math.min(parseFloat(value1), parseFloat(value2)), \"px\");else return Math.min(value1, value2);\n    },\n    getMax: function getMax(value1, value2) {\n      if (this.valueIsPx) return \"\".concat(Math.max(parseFloat(value1), parseFloat(value2)), \"px\");else return Math.max(value1, value2);\n    },\n    getAnotherOffset: function getAnotherOffset(value) {\n      var res = 0;\n      if (this.valueIsPx) res = \"\".concat(this.$refs.outerWrapper[this.offsetSize] - parseFloat(value), \"px\");else res = 1 - value;\n      return res;\n    },\n    handleMove: function handleMove(e) {\n      var pageOffset = this.isHorizontal ? e.pageX : e.pageY;\n      var offset = pageOffset - this.initOffset;\n      var outerWidth = this.$refs.outerWrapper[this.offsetSize];\n      var value = this.valueIsPx ? \"\".concat(parseFloat(this.oldOffset) + offset, \"px\") : this.px2percent(outerWidth * this.oldOffset + offset, outerWidth);\n      var anotherValue = this.getAnotherOffset(value);\n      if (parseFloat(value) <= parseFloat(this.computedMin)) value = this.getMax(value, this.computedMin);\n      if (parseFloat(anotherValue) <= parseFloat(this.computedMax)) value = this.getAnotherOffset(this.getMax(anotherValue, this.computedMax));\n      e.atMin = this.value === this.computedMin;\n      e.atMax = this.valueIsPx ? this.getAnotherOffset(this.value) === this.computedMax : this.getAnotherOffset(this.value).toFixed(5) === this.computedMax.toFixed(5);\n      this.$emit('input', value);\n      this.$emit('on-moving', e);\n    },\n    handleUp: function handleUp() {\n      this.isMoving = false;\n      off(document, 'mousemove', this.handleMove);\n      off(document, 'mouseup', this.handleUp);\n      this.$emit('on-move-end');\n    },\n    handleMousedown: function handleMousedown(e) {\n      this.initOffset = this.isHorizontal ? e.pageX : e.pageY;\n      this.oldOffset = this.value;\n      this.isMoving = true;\n      on(document, 'mousemove', this.handleMove);\n      on(document, 'mouseup', this.handleUp);\n      this.$emit('on-move-start');\n    }\n  },\n  watch: {\n    value: function value() {\n      this.offset = (this.valueIsPx ? this.px2percent(this.value, this.$refs.outerWrapper[this.offsetSize]) : this.value) * 10000 / 100;\n    }\n  },\n  mounted: function mounted() {\n    var _this = this;\n\n    this.$nextTick(function () {\n      _this.offset = (_this.valueIsPx ? _this.px2percent(_this.value, _this.$refs.outerWrapper[_this.offsetSize]) : _this.value) * 10000 / 100;\n    });\n  }\n};",null]}