{"remainingRequest":"C:\\work\\code\\iview-admin\\node_modules\\babel-loader\\lib\\index.js!C:\\work\\code\\iview-admin\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!C:\\work\\code\\iview-admin\\src\\components\\split-pane\\split.vue?vue&type=script&lang=js&","dependencies":[{"path":"C:\\work\\code\\iview-admin\\src\\components\\split-pane\\split.vue","mtime":1535094297031},{"path":"C:\\work\\code\\iview-admin\\.babelrc","mtime":1535094296553},{"path":"C:\\work\\code\\iview-admin\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1535091260613},{"path":"C:\\work\\code\\iview-admin\\node_modules\\babel-loader\\lib\\index.js","mtime":1529635966000},{"path":"C:\\work\\code\\iview-admin\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.number.constructor\";\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport { oneOf, on, off } from '@/libs/tools';\nimport Trigger from './trigger.vue';\nexport default {\n  name: 'SplitPane',\n  components: {\n    Trigger: Trigger\n  },\n  props: {\n    value: {\n      type: [Number, String],\n      default: 0.5\n    },\n    mode: {\n      validator: function validator(value) {\n        return oneOf(value, ['horizontal', 'vertical']);\n      },\n      default: 'horizontal'\n    },\n    min: {\n      type: [Number, String],\n      default: '40px'\n    },\n    max: {\n      type: [Number, String],\n      default: '40px'\n    }\n  },\n\n  /**\r\n   * Events\r\n   * @on-move-start\r\n   * @on-moving 返回值：事件对象，但是在事件对象中加入了两个参数：atMin(当前是否在最小值处), atMax(当前是否在最大值处)\r\n   * @on-move-end\r\n   */\n  data: function data() {\n    return {\n      prefix: 'ivu-split',\n      offset: 0,\n      oldOffset: 0,\n      isMoving: false\n    };\n  },\n  computed: {\n    wrapperClasses: function wrapperClasses() {\n      return [\"\".concat(this.prefix, \"-wrapper\"), this.isMoving ? 'no-select' : ''];\n    },\n    isHorizontal: function isHorizontal() {\n      return this.mode === 'horizontal';\n    },\n    anotherOffset: function anotherOffset() {\n      return 100 - this.offset;\n    },\n    valueIsPx: function valueIsPx() {\n      return typeof this.value === 'string';\n    },\n    offsetSize: function offsetSize() {\n      return this.isHorizontal ? 'offsetWidth' : 'offsetHeight';\n    },\n    computedMin: function computedMin() {\n      return this.getComputedThresholdValue('min');\n    },\n    computedMax: function computedMax() {\n      return this.getComputedThresholdValue('max');\n    }\n  },\n  methods: {\n    px2percent: function px2percent(numerator, denominator) {\n      return parseFloat(numerator) / parseFloat(denominator);\n    },\n    getComputedThresholdValue: function getComputedThresholdValue(type) {\n      var size = this.$refs.outerWrapper[this.offsetSize];\n      if (this.valueIsPx) return typeof this[type] === 'string' ? this[type] : size * this[type];else return typeof this[type] === 'string' ? this.px2percent(this[type], size) : this[type];\n    },\n    getMin: function getMin(value1, value2) {\n      if (this.valueIsPx) return \"\".concat(Math.min(parseFloat(value1), parseFloat(value2)), \"px\");else return Math.min(value1, value2);\n    },\n    getMax: function getMax(value1, value2) {\n      if (this.valueIsPx) return \"\".concat(Math.max(parseFloat(value1), parseFloat(value2)), \"px\");else return Math.max(value1, value2);\n    },\n    getAnotherOffset: function getAnotherOffset(value) {\n      var res = 0;\n      if (this.valueIsPx) res = \"\".concat(this.$refs.outerWrapper[this.offsetSize] - parseFloat(value), \"px\");else res = 1 - value;\n      return res;\n    },\n    handleMove: function handleMove(e) {\n      var pageOffset = this.isHorizontal ? e.pageX : e.pageY;\n      var offset = pageOffset - this.initOffset;\n      var outerWidth = this.$refs.outerWrapper[this.offsetSize];\n      var value = this.valueIsPx ? \"\".concat(parseFloat(this.oldOffset) + offset, \"px\") : this.px2percent(outerWidth * this.oldOffset + offset, outerWidth);\n      var anotherValue = this.getAnotherOffset(value);\n      if (parseFloat(value) <= parseFloat(this.computedMin)) value = this.getMax(value, this.computedMin);\n      if (parseFloat(anotherValue) <= parseFloat(this.computedMax)) value = this.getAnotherOffset(this.getMax(anotherValue, this.computedMax));\n      e.atMin = this.value === this.computedMin;\n      e.atMax = this.valueIsPx ? this.getAnotherOffset(this.value) === this.computedMax : this.getAnotherOffset(this.value).toFixed(5) === this.computedMax.toFixed(5);\n      this.$emit('input', value);\n      this.$emit('on-moving', e);\n    },\n    handleUp: function handleUp() {\n      this.isMoving = false;\n      off(document, 'mousemove', this.handleMove);\n      off(document, 'mouseup', this.handleUp);\n      this.$emit('on-move-end');\n    },\n    handleMousedown: function handleMousedown(e) {\n      this.initOffset = this.isHorizontal ? e.pageX : e.pageY;\n      this.oldOffset = this.value;\n      this.isMoving = true;\n      on(document, 'mousemove', this.handleMove);\n      on(document, 'mouseup', this.handleUp);\n      this.$emit('on-move-start');\n    }\n  },\n  watch: {\n    value: function value() {\n      this.offset = (this.valueIsPx ? this.px2percent(this.value, this.$refs.outerWrapper[this.offsetSize]) : this.value) * 10000 / 100;\n    }\n  },\n  mounted: function mounted() {\n    var _this = this;\n\n    this.$nextTick(function () {\n      _this.offset = (_this.valueIsPx ? _this.px2percent(_this.value, _this.$refs.outerWrapper[_this.offsetSize]) : _this.value) * 10000 / 100;\n    });\n  }\n};",{"version":3,"sources":["split.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\r\n  <div ref=\"outerWrapper\" :class=\"wrapperClasses\">\r\n    <div v-if=\"isHorizontal\" :class=\"`${prefix}-horizontal`\">\r\n      <div :style=\"{right: `${anotherOffset}%`}\" :class=\"[`${prefix}-pane`, 'left-pane']\"><slot name=\"left\"/></div>\r\n      <div :class=\"`${prefix}-trigger-con`\" :style=\"{left: `${offset}%`}\" @mousedown=\"handleMousedown\">\r\n        <slot name=\"trigger\">\r\n          <trigger mode=\"vertical\"/>\r\n        </slot>\r\n      </div>\r\n      <div :style=\"{left: `${offset}%`}\" :class=\"[`${prefix}-pane`, 'right-pane']\"><slot name=\"right\"/></div>\r\n    </div>\r\n    <div v-else :class=\"`${prefix}-vertical`\">\r\n      <div :style=\"{bottom: `${anotherOffset}%`}\" :class=\"[`${prefix}-pane`, 'top-pane']\"><slot name=\"top\"/></div>\r\n     <div :class=\"`${prefix}-trigger-con`\" :style=\"{top: `${offset}%`}\" @mousedown=\"handleMousedown\">\r\n        <slot name=\"trigger\">\r\n          <trigger mode=\"horizontal\"/>\r\n        </slot>\r\n      </div>\r\n      <div :style=\"{top: `${offset}%`}\" :class=\"[`${prefix}-pane`, 'bottom-pane']\"><slot name=\"bottom\"/></div>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport { oneOf, on, off } from '@/libs/tools'\r\nimport Trigger from './trigger.vue'\r\nexport default {\r\n  name: 'SplitPane',\r\n  components: {\r\n    Trigger\r\n  },\r\n  props: {\r\n    value: {\r\n      type: [Number, String],\r\n      default: 0.5\r\n    },\r\n    mode: {\r\n      validator (value) {\r\n        return oneOf(value, ['horizontal', 'vertical'])\r\n      },\r\n      default: 'horizontal'\r\n    },\r\n    min: {\r\n      type: [Number, String],\r\n      default: '40px'\r\n    },\r\n    max: {\r\n      type: [Number, String],\r\n      default: '40px'\r\n    }\r\n  },\r\n  /**\r\n   * Events\r\n   * @on-move-start\r\n   * @on-moving 返回值：事件对象，但是在事件对象中加入了两个参数：atMin(当前是否在最小值处), atMax(当前是否在最大值处)\r\n   * @on-move-end\r\n   */\r\n  data () {\r\n    return {\r\n      prefix: 'ivu-split',\r\n      offset: 0,\r\n      oldOffset: 0,\r\n      isMoving: false\r\n    }\r\n  },\r\n  computed: {\r\n    wrapperClasses () {\r\n      return [\r\n        `${this.prefix}-wrapper`,\r\n        this.isMoving ? 'no-select' : ''\r\n      ]\r\n    },\r\n    isHorizontal () {\r\n      return this.mode === 'horizontal'\r\n    },\r\n    anotherOffset () {\r\n      return 100 - this.offset\r\n    },\r\n    valueIsPx () {\r\n      return typeof this.value === 'string'\r\n    },\r\n    offsetSize () {\r\n      return this.isHorizontal ? 'offsetWidth' : 'offsetHeight'\r\n    },\r\n    computedMin () {\r\n      return this.getComputedThresholdValue('min')\r\n    },\r\n    computedMax () {\r\n      return this.getComputedThresholdValue('max')\r\n    }\r\n  },\r\n  methods: {\r\n    px2percent (numerator, denominator) {\r\n      return parseFloat(numerator) / parseFloat(denominator)\r\n    },\r\n    getComputedThresholdValue (type) {\r\n      let size = this.$refs.outerWrapper[this.offsetSize]\r\n      if (this.valueIsPx) return typeof this[type] === 'string' ? this[type] : size * this[type]\r\n      else return typeof this[type] === 'string' ? this.px2percent(this[type], size) : this[type]\r\n    },\r\n    getMin (value1, value2) {\r\n      if (this.valueIsPx) return `${Math.min(parseFloat(value1), parseFloat(value2))}px`\r\n      else return Math.min(value1, value2)\r\n    },\r\n    getMax (value1, value2) {\r\n      if (this.valueIsPx) return `${Math.max(parseFloat(value1), parseFloat(value2))}px`\r\n      else return Math.max(value1, value2)\r\n    },\r\n    getAnotherOffset (value) {\r\n      let res = 0\r\n      if (this.valueIsPx) res = `${this.$refs.outerWrapper[this.offsetSize] - parseFloat(value)}px`\r\n      else res = 1 - value\r\n      return res\r\n    },\r\n    handleMove (e) {\r\n      let pageOffset = this.isHorizontal ? e.pageX : e.pageY\r\n      let offset = pageOffset - this.initOffset\r\n      let outerWidth = this.$refs.outerWrapper[this.offsetSize]\r\n      let value = this.valueIsPx ? `${parseFloat(this.oldOffset) + offset}px` : (this.px2percent(outerWidth * this.oldOffset + offset, outerWidth))\r\n      let anotherValue = this.getAnotherOffset(value)\r\n      if (parseFloat(value) <= parseFloat(this.computedMin)) value = this.getMax(value, this.computedMin)\r\n      if (parseFloat(anotherValue) <= parseFloat(this.computedMax)) value = this.getAnotherOffset(this.getMax(anotherValue, this.computedMax))\r\n      e.atMin = this.value === this.computedMin\r\n      e.atMax = this.valueIsPx ? this.getAnotherOffset(this.value) === this.computedMax : this.getAnotherOffset(this.value).toFixed(5) === this.computedMax.toFixed(5)\r\n      this.$emit('input', value)\r\n      this.$emit('on-moving', e)\r\n    },\r\n    handleUp () {\r\n      this.isMoving = false\r\n      off(document, 'mousemove', this.handleMove)\r\n      off(document, 'mouseup', this.handleUp)\r\n      this.$emit('on-move-end')\r\n    },\r\n    handleMousedown (e) {\r\n      this.initOffset = this.isHorizontal ? e.pageX : e.pageY\r\n      this.oldOffset = this.value\r\n      this.isMoving = true\r\n      on(document, 'mousemove', this.handleMove)\r\n      on(document, 'mouseup', this.handleUp)\r\n      this.$emit('on-move-start')\r\n    }\r\n  },\r\n  watch: {\r\n    value () {\r\n      this.offset = (this.valueIsPx ? this.px2percent(this.value, this.$refs.outerWrapper[this.offsetSize]) : this.value) * 10000 / 100\r\n    }\r\n  },\r\n  mounted () {\r\n    this.$nextTick(() => {\r\n      this.offset = (this.valueIsPx ? this.px2percent(this.value, this.$refs.outerWrapper[this.offsetSize]) : this.value) * 10000 / 100\r\n    })\r\n  }\r\n}\r\n</script>\r\n\r\n<style lang=\"less\">\r\n@import './index.less';\r\n</style>\r\n"],"sourceRoot":"src\\components\\split-pane"}]}